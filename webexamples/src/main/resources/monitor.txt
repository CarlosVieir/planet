Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора.
Монитор экземпляра может иметь только одного владельца. При попытке кон-
курирующего доступа к объекту, чей монитор имеет владельца, желающий за-
блокировать объект-ресурс поток должен подождать освобождения монитора
этого объекта и только после этого завладеть им и начать использование объек-
та-ресурса. Каждый экземпляр любого класса имеет монитор. Методы wait(),
wait(long inmillis), notify(), notifyAll() корректно срабатывают только на  эк-
земплярах, чей монитор уже кем-то захвачен. Статический метод захватывает
монитор экземпляра класса Class, того класса, на котором он вызван. Существует
в единственном экземпляре. Нестатический метод захватывает монитор экзем-
пляра класса, на котором он вызван.

Методы wait(), notify() и notifyAll()
Эти методы никогда не переопределяются и используются только в исход-
ном виде. Вызываются только внутри синхронизированного блока или метода
на объекте, монитор которого захвачен текущим потоком. Попытка обращения
к данным методам вне синхронизации или на несинхронизированном объекте
(со  свободным монитором) приводит к  генерации исключительной ситуации
IllegalMonitorStateException. В примере #15 рассмотрено взаимодействие ме-
тодов wait() и notify() при освобождении и возврате блокировки в synchronized
блоке. Эти методы используются для управления потоками в ситуации, когда
необходимо задать определенную последовательность действий без повторного
запуска потоков.
Метод wait(), вызванный внутри синхронизированного блока или метода,
останавливает выполнение текущего потока и освобождает от блокировки за-
хваченный объект. Возвратить блокировку объекта потоку можно вызовом ме-
тода notify() для одного потока или notifyAll() для всех потоков. Если ожидаю-
щих потоков несколько, то после вызова метода notify() невозможно определить,
какой поток из  ожидающих потоков заблокирует объект. Вызов может быть
осуществлен только из  другого потока, заблокировавшего в  свою очередь
тот же самый объект.

Семафор

Семафор позволяет управлять доступом к ресурсам или просто работой по-
токов на  основе запрещений-разрешений. Семафор всегда устанавливается
на предельное положительное число потоков, одновременное функционирова-
ние которых может быть разрешено. При превышении предельного числа все
желающие работать потоки будут приостановлены до освобождения семафора
одним из работающих по его разрешению потоков. Уменьшение счетчика досту-
па производится методами void acquire() и его оболочки boolean tryAcquire().
Оба метода занимают семафор, если он свободен. Если  же семафор занят,
то метод tryAcquire() возвращает ложь и пропускает поток дальше, что позво-
ляет при необходимости отказаться от  дальнейшей работы потоку, который
не смог получить семафор. Метод acquire() при невозможности захвата сема-
фора остановит поток до тех пор, пока хотя бы другой поток не освободит се-
мафор. Метод boolean tryAcquire(long timeout,TimeUnit unit) возвращает
ложь, если время ожидания превышено, т. е. за указанное время поток не полу-
чил от  семафора разрешение работать и  пропускает поток дальше. Метод
release() освобождает семафор и  увеличивает счетчик на  единицу. Простое
надежное стандартное взаимодействие методов acquire() и  release() демон-
стрирует следующий фрагмент.

Многие задачи могут быть разделены на подзадачи и выполняться параллель-
но. По  достижении некоторой данной точки всеми параллельными потоками
подводится итог и определяется общий результат. Если стоит задача задержать
заданное число потоков до  достижения ими определенной точки синхрониза-
ции, то используются классы-барьеры. После того, как все потоки достигли этой
самой точки, они будут разблокированы и могут продолжать выполнение. Класс
CyclicBarrier определяет минимальное число потоков, которое может быть
остановлено барьером. Кроме этого барьер сам может быть проинициализиро-
ван потоком, который будет запускаться при снятии барьера. Методы int await()
и int await(long timeout, TimeUnit unit) останавливают поток, использующий
барьер до тех пор, пока число потоков достигнет заданного числа в классе-барьере.
Метод await() возвращает порядковый номер достижения потоком барьерной точки.
Метод boolean isBroken() проверяет состояние барьера. Метод reset() сбрасывает со-
стояние барьера к моменту инициализации. Метод int getNumberWaiting() позволя-
ет определить число ожидаемых барьером потоков до его снятия. Экземпляр
CyclicBarrier можно использовать повторно.
Процесс проведения аукциона подразумевает корректное использование клас-
са CyclicBarrier. Класс Auction определяет список конкурирующих предложений
от клиентов и размер барьера. Чтобы приложение работало корректно, необходи-
мо, чтобы размер списка совпадал со  значением константы BIDS_NUMBER.
Барьер инициализируется потоком определения победителя торгов, который
запустится после того, как все предложения будут объявлены. Если потоков
будет запущено больше чем размер барьера, то «лишние» предложения могут
быть не учтены при вычислении победителя, если же потоков будет меньше,
то приложение окажется в состоянии deadlock. Для предотвращения подобных
ситуаций следует использовать метод await() с параметрами.

Еще один вид барьера представляет класс CountDownLatch. Экземпляр класса
инициализируется начальным значением числа ожидающих снятия «щеколды»
потоков. В отличие от CyclicBarrier, метод await() просто останавливает поток без
всяких изменений значения счетчика. Значение счетчика снижается вызовом мето-
да countDown(), т. е. «щеколда» сдвигается на единицу. Когда счетчик обнулится,
барьеры, поставленные методом await(), снимаются для всех ожидающих разре-
шения потоков. Крайне желательно, чтобы метод await() был вызван раньше, чем
метод countDown(). Последнему безразлично, вызывался метод await() или нет,
счетчик все равно будет уменьшен на единицу. Если счетчик равен нулю, то «лиш-
ние» вызовы метода countDown() будут проигнорированы.
Демонстрацией возможностей класса CountDownLatch может служить за-
дача выполнения студентами набора заданий (тестов). Студенту предлагается
для выполнения набор заданий. Он выполняет их и переходит в режим ожида-
ния оценок по  всем заданиям, чтобы вычислить среднее значение оценки.
Преподаватель (Tutor) проверяет задание и после каждого проверенного зада-
ния сдвигает «щеколду» на  единицу. Когда все задания студента проверены,
счетчик становится равным нулю и барьер снимается, производятся необходи-
мые вычисления в классе Student.

//http://habrahabr.ru/company/luxoft/blog/157273/